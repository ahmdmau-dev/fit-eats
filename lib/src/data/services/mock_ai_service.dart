import 'package:dartz/dartz.dart';
import 'package:fiteats/src/core/constants/enums.dart';
import 'package:fiteats/src/core/errors/failures.dart';
import 'package:fiteats/src/domain/entities/meal_plan.dart';
import 'package:fiteats/src/domain/entities/nutrition.dart';
import 'package:fiteats/src/domain/entities/recipe.dart';
import 'package:fiteats/src/domain/entities/workout_exercise.dart';
import 'package:fiteats/src/domain/entities/workout_plan.dart';
import 'package:fiteats/src/domain/services/ai_service.dart';
import 'package:injectable/injectable.dart';
import 'package:uuid/uuid.dart';

@LazySingleton(as: AIService, env: ['mock'])
class MockAIService implements AIService {
  MockAIService() : _uuid = const Uuid();

  final Uuid _uuid;

  @override
  String get providerName => 'Mock AI';

  @override
  Future<Either<Failure, MealPlan>> generateMealPlan({
    required String userId,
    required DateTime date,
    required int calorieTarget,
    required List<String> dietaryPreferences,
    required List<String> allergies,
  }) async {
    // Simulate AI processing time
    await Future.delayed(const Duration(seconds: 2));

    try {
      // Generate mock recipes for each meal
      final breakfast = _generateMockRecipe(
        mealTime: MealTime.breakfast,
        calorieTarget: (calorieTarget * 0.25).round(),
      );

      final lunch = _generateMockRecipe(
        mealTime: MealTime.lunch,
        calorieTarget: (calorieTarget * 0.35).round(),
      );

      final dinner = _generateMockRecipe(
        mealTime: MealTime.dinner,
        calorieTarget: (calorieTarget * 0.30).round(),
      );

      final morningSnack = _generateMockRecipe(
        mealTime: MealTime.morningSnack,
        calorieTarget: (calorieTarget * 0.05).round(),
      );

      final afternoonSnack = _generateMockRecipe(
        mealTime: MealTime.afternoonSnack,
        calorieTarget: (calorieTarget * 0.05).round(),
      );

      final mealPlan = MealPlan(
        id: _uuid.v4(),
        userId: userId,
        date: date,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        breakfast: breakfast,
        morningSnack: morningSnack,
        lunch: lunch,
        afternoonSnack: afternoonSnack,
        dinner: dinner,
        notes: 'Generated by Mock AI - Calorie target: $calorieTarget kcal',
      );

      return Right(mealPlan);
    } catch (e) {
      return Left(
        Failure.ai(
          message: 'Mock AI failed to generate meal plan: $e',
          provider: providerName,
        ),
      );
    }
  }

  @override
  Future<Either<Failure, WorkoutPlan>> generateWorkoutPlan({
    required String userId,
    required DateTime date,
    required String level,
    required String type,
    required int duration,
  }) async {
    // Simulate AI processing time
    await Future.delayed(const Duration(seconds: 2));

    try {
      // Generate mock exercises based on level and type
      final exercises = _generateMockExercises(
        level: level,
        type: type,
        duration: duration,
      );

      final workoutPlan = WorkoutPlan(
        id: _uuid.v4(),
        userId: userId,
        title: 'Mock $level ${type.toUpperCase()} Workout',
        description:
            'A $duration-minute $level level $type workout generated by Mock AI',
        date: date,
        level: _parseWorkoutLevel(level),
        type: _parseWorkoutType(type),
        exercises: exercises,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        notes: 'Generated by Mock AI - $duration minutes',
      );

      return Right(workoutPlan);
    } catch (e) {
      return Left(
        Failure.ai(
          message: 'Mock AI failed to generate workout plan: $e',
          provider: providerName,
        ),
      );
    }
  }

  Recipe _generateMockRecipe({
    required MealTime mealTime,
    required int calorieTarget,
  }) {
    final mealNames = {
      MealTime.breakfast: [
        'Oatmeal with Berries',
        'Greek Yogurt Parfait',
        'Avocado Toast',
        'Protein Smoothie Bowl',
      ],
      MealTime.morningSnack: [
        'Apple with Almond Butter',
        'Mixed Nuts',
        'Protein Bar',
      ],
      MealTime.lunch: [
        'Grilled Chicken Salad',
        'Quinoa Buddha Bowl',
        'Turkey Wrap',
        'Salmon with Veggies',
      ],
      MealTime.afternoonSnack: [
        'Hummus with Veggies',
        'Greek Yogurt',
        'Trail Mix',
      ],
      MealTime.dinner: [
        'Grilled Salmon with Quinoa',
        'Chicken Stir-Fry',
        'Lean Beef with Sweet Potato',
        'Tofu Buddha Bowl',
      ],
      MealTime.eveningSnack: ['Cottage Cheese', 'Protein Shake', 'Berries'],
    };

    final name = (mealNames[mealTime] ?? ['Mock Meal']).first;

    // Calculate macros (rough estimates)
    final protein = (calorieTarget * 0.30 / 4).round(); // 30% protein
    final carbs = (calorieTarget * 0.40 / 4).round(); // 40% carbs
    final fats = (calorieTarget * 0.30 / 9).round(); // 30% fats

    return Recipe(
      id: _uuid.v4(),
      title: name,
      description: 'A delicious $name perfect for ${mealTime.name}',
      ingredients: [
        'Main ingredient 1',
        'Main ingredient 2',
        'Seasoning',
        'Optional garnish',
      ],
      instructions: [
        'Prepare ingredients',
        'Cook or combine as needed',
        'Season to taste',
        'Serve and enjoy',
      ],
      nutrition: Nutrition(
        calories: calorieTarget.toDouble(),
        protein: protein.toDouble(),
        carbs: carbs.toDouble(),
        fats: fats.toDouble(),
        fiber: 5,
        sugar: 8,
        sodium: 400,
      ),
      mealTime: mealTime,
      prepTime: 10,
      cookTime: 15,
      servings: 1,
      tags: ['healthy', 'balanced', 'mock'],
    );
  }

  List<WorkoutExercise> _generateMockExercises({
    required String level,
    required String type,
    required int duration,
  }) {
    final exercises = <WorkoutExercise>[];

    // Warmup
    exercises.add(
      WorkoutExercise(
        id: _uuid.v4(),
        name: 'Dynamic Warmup',
        description: 'Light cardio and dynamic stretching',
        type: ExerciseType.warmup,
        duration: 5,
        restTime: 0,
      ),
    );

    // Main exercises based on type
    final exerciseCount = duration ~/ 10; // Rough estimate
    final exerciseDuration = (duration - 10) ~/ exerciseCount; // Minus warmup/cooldown

    if (type.toLowerCase() == 'cardio') {
      exercises.addAll([
        WorkoutExercise(
          id: _uuid.v4(),
          name: 'Running',
          description: 'Moderate pace running',
          type: ExerciseType.cardio,
          duration: exerciseDuration,
          restTime: 30,
        ),
        WorkoutExercise(
          id: _uuid.v4(),
          name: 'Jumping Jacks',
          description: 'High intensity jumping jacks',
          type: ExerciseType.cardio,
          duration: exerciseDuration,
          restTime: 30,
        ),
      ]);
    } else {
      exercises.addAll([
        WorkoutExercise(
          id: _uuid.v4(),
          name: 'Push-ups',
          description: 'Standard push-ups',
          type: ExerciseType.strength,
          sets: 3,
          reps: level == 'beginner' ? 10 : (level == 'intermediate' ? 15 : 20),
          restTime: 60,
          muscleGroups: ['chest', 'triceps', 'shoulders'],
        ),
        WorkoutExercise(
          id: _uuid.v4(),
          name: 'Squats',
          description: 'Bodyweight squats',
          type: ExerciseType.strength,
          sets: 3,
          reps: level == 'beginner' ? 12 : (level == 'intermediate' ? 18 : 25),
          restTime: 60,
          muscleGroups: ['legs', 'glutes'],
        ),
      ]);
    }

    // Cooldown
    exercises.add(
      WorkoutExercise(
        id: _uuid.v4(),
        name: 'Cooldown Stretch',
        description: 'Static stretching and relaxation',
        type: ExerciseType.cooldown,
        duration: 5,
        restTime: 0,
      ),
    );

    return exercises;
  }

  WorkoutLevel _parseWorkoutLevel(String level) {
    switch (level.toLowerCase()) {
      case 'beginner':
        return WorkoutLevel.beginner;
      case 'intermediate':
        return WorkoutLevel.intermediate;
      case 'advanced':
        return WorkoutLevel.advanced;
      default:
        return WorkoutLevel.beginner;
    }
  }

  WorkoutType _parseWorkoutType(String type) {
    switch (type.toLowerCase()) {
      case 'home':
        return WorkoutType.home;
      case 'gym':
        return WorkoutType.gym;
      case 'mixed':
        return WorkoutType.mixed;
      default:
        return WorkoutType.home;
    }
  }
}
